// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class Gtfsdata {

  #region Extension registration
  public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
  }
  #endregion
  #region Static variables
  internal static pbd::MessageDescriptor internal__static_GTFSData__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData, global::GTFSData.Builder> internal__static_GTFSData__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_TempListOfStops__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.TempListOfStops, global::GTFSData.Types.TempListOfStops.Builder> internal__static_GTFSData_TempListOfStops__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_Route__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Route, global::GTFSData.Types.Route.Builder> internal__static_GTFSData_Route__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_Trip__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Trip, global::GTFSData.Types.Trip.Builder> internal__static_GTFSData_Trip__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_StopTime__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.StopTime, global::GTFSData.Types.StopTime.Builder> internal__static_GTFSData_StopTime__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_Stop__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Stop, global::GTFSData.Types.Stop.Builder> internal__static_GTFSData_Stop__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_ShapeSegment__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.ShapeSegment, global::GTFSData.Types.ShapeSegment.Builder> internal__static_GTFSData_ShapeSegment__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_GTFSData_Shape__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Shape, global::GTFSData.Types.Shape.Builder> internal__static_GTFSData_Shape__FieldAccessorTable;
  #endregion
  #region Descriptor
  public static pbd::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbd::FileDescriptor descriptor;
  
  static Gtfsdata() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        "Cg9ndGZzLWRhdGEucHJvdG8ing4KCEdURlNEYXRhGjAKD1RlbXBMaXN0T2ZT" + 
        "dG9wcxIdCgVzdG9wcxgBIAMoCzIOLkdURlNEYXRhLlN0b3AaiwMKBVJvdXRl" + 
        "EhAKCHJvdXRlX2lkGAEgAigJEhEKCWFnZW5jeV9pZBgCIAEoCRIYChByb3V0" + 
        "ZV9zaG9ydF9uYW1lGAMgAigJEhcKD3JvdXRlX2xvbmdfbmFtZRgEIAIoCRIS" + 
        "Cgpyb3V0ZV9kZXNjGAUgASgJEi0KCnJvdXRlX3R5cGUYBiACKA4yGS5HVEZT" + 
        "RGF0YS5Sb3V0ZS5Sb3V0ZVR5cGUSEQoJcm91dGVfdXJsGAcgASgJEhMKC3Jv" + 
        "dXRlX2NvbG9yGAggASgJEhgKEHJvdXRlX3RleHRfY29sb3IYCSABKAkSHQoF" + 
        "dHJpcHMYCiADKAsyDi5HVEZTRGF0YS5UcmlwIoUBCglSb3V0ZVR5cGUSGgoW" + 
        "VFJBTV9TVFJFRVRDQVJfT1JfUkFJTBAAEhMKD1NVQldBWV9PUl9NRVRSTxAB" + 
        "EggKBFJBSUwQAhIHCgNCVVMQAxIJCgVGRVJSWRAEEg0KCUNBQkxFX0NBUhAF" + 
        "EgsKB0dPTkRPTEEQBhINCglGVU5JQ1VMQVIQBxr/AgoEVHJpcBIQCghyb3V0" + 
        "ZV9pZBgBIAIoCRISCgpzZXJ2aWNlX2lkGAIgAigJEg8KB3RyaXBfaWQYAyAC" + 
        "KAkSFwoPdHJpcF9zaG9ydF9uYW1lGAQgASgJEi4KDGRpcmVjdGlvbl9pZBgF" + 
        "IAEoDjIYLkdURlNEYXRhLlRyaXAuRGlyZWN0aW9uEhAKCGJsb2NrX2lkGAYg" + 
        "ASgJEiIKCXRyaXBTaGFwZRgHIAEoCzIPLkdURlNEYXRhLlNoYXBlEjYKFXdo" + 
        "ZWVsY2hhaXJfYWNjZXNzaWJsZRgIIAEoDjIXLkdURlNEYXRhLkFjY2Vzc2li" + 
        "aWxpdHkSLgoNYmlrZXNfYWxsb3dlZBgJIAEoDjIXLkdURlNEYXRhLkFjY2Vz" + 
        "c2liaWxpdHkSJQoJc3RvcFRpbWVzGAogAygLMhIuR1RGU0RhdGEuU3RvcFRp" + 
        "bWUiMgoJRGlyZWN0aW9uEhIKDkRJUkVDVElPTl9aRVJPEAASEQoNRElSRUNU" + 
        "SU9OX09ORRABGpcDCghTdG9wVGltZRIPCgd0cmlwX2lkGAEgAigJEhQKDGFy" + 
        "cml2YWxfdGltZRgCIAIoCRIWCg5kZXBhcnR1cmVfdGltZRgDIAIoCRIPCgdz" + 
        "dG9wX2lkGAQgAigJEhUKDXN0b3Bfc2VxdWVuY2UYBSACKA0SFQoNc3RvcF9o" + 
        "ZWFkc2lnbhgGIAEoCRI5CgtwaWNrdXBfdHlwZRgHIAEoDjIkLkdURlNEYXRh" + 
        "LlN0b3BUaW1lLlBpY2t1cERyb3BvZmZUeXBlEjsKDWRyb3Bfb2ZmX3R5cGUY" + 
        "CCABKA4yJC5HVEZTRGF0YS5TdG9wVGltZS5QaWNrdXBEcm9wb2ZmVHlwZRIb" + 
        "ChNzaGFwZV9kaXN0X3RyYXZlbGVkGAkgASgCIngKEVBpY2t1cERyb3BvZmZU" + 
        "eXBlEhcKE1JFR1VMQVJMWV9TQ0hFRFVMRUQQABIXChNOT19QSUNLVVBfQVZB" + 
        "SUxBQkxFEAESFQoRTVVTVF9QSE9ORV9BR0VOQ1kQAhIaChZDT09SRElOQVRF" + 
        "X1dJVEhfRFJJVkVSEAMa1wIKBFN0b3ASDwoHc3RvcF9pZBgBIAIoCRIRCglz" + 
        "dG9wX2NvZGUYAiABKAkSEQoJc3RvcF9uYW1lGAMgAigJEhEKCXN0b3BfZGVz" + 
        "YxgEIAEoCRIQCghzdG9wX2xhdBgGIAIoCRIQCghzdG9wX2xvbhgHIAIoCRIP" + 
        "Cgd6b25lX2lkGAggASgJEhAKCHN0b3BfdXJsGAkgASgJEjIKDWxvY2F0aW9u" + 
        "X3R5cGUYCiABKA4yGy5HVEZTRGF0YS5TdG9wLkxvY2F0aW9uVHlwZRIWCg5w" + 
        "YXJlbnRfc3RhdGlvbhgLIAEoCRIVCg1zdG9wX3RpbWV6b25lGAwgASgJEjQK" + 
        "E3doZWVsY2hhaXJfYm9hcmRpbmcYDSABKA4yFy5HVEZTRGF0YS5BY2Nlc3Np" + 
        "YmlsaXR5IiUKDExvY2F0aW9uVHlwZRIICgRTVE9QEAASCwoHU1RBVElPThAB" + 
        "GlcKDFNoYXBlU2VnbWVudBIUCgxzaGFwZV9wdF9sYXQYASACKAkSFAoMc2hh" + 
        "cGVfcHRfbG9uGAIgAigJEhsKE3NoYXBlX2Rpc3RfdHJhdmVsZWQYAyABKAka" + 
        "QQoFU2hhcGUSEAoIc2hhcGVfaWQYASACKAkSJgoGc2hhcGVzGAIgAygLMhYu" + 
        "R1RGU0RhdGEuU2hhcGVTZWdtZW50IkAKDUFjY2Vzc2liaWxpdHkSCwoHTk9f" + 
        "SU5GTxAAEg4KCkFDQ0VTU0lCTEUQARISCg5OT1RfQUNDRVNTSUJMRRAC");
    pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
      descriptor = root;
      internal__static_GTFSData__Descriptor = Descriptor.MessageTypes[0];
      internal__static_GTFSData__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData, global::GTFSData.Builder>(internal__static_GTFSData__Descriptor,
              new string[] { });
      internal__static_GTFSData_TempListOfStops__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[0];
      internal__static_GTFSData_TempListOfStops__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.TempListOfStops, global::GTFSData.Types.TempListOfStops.Builder>(internal__static_GTFSData_TempListOfStops__Descriptor,
              new string[] { "Stops", });
      internal__static_GTFSData_Route__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[1];
      internal__static_GTFSData_Route__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Route, global::GTFSData.Types.Route.Builder>(internal__static_GTFSData_Route__Descriptor,
              new string[] { "RouteId", "AgencyId", "RouteShortName", "RouteLongName", "RouteDesc", "RouteType", "RouteUrl", "RouteColor", "RouteTextColor", "Trips", });
      internal__static_GTFSData_Trip__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[2];
      internal__static_GTFSData_Trip__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Trip, global::GTFSData.Types.Trip.Builder>(internal__static_GTFSData_Trip__Descriptor,
              new string[] { "RouteId", "ServiceId", "TripId", "TripShortName", "DirectionId", "BlockId", "TripShape", "WheelchairAccessible", "BikesAllowed", "StopTimes", });
      internal__static_GTFSData_StopTime__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[3];
      internal__static_GTFSData_StopTime__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.StopTime, global::GTFSData.Types.StopTime.Builder>(internal__static_GTFSData_StopTime__Descriptor,
              new string[] { "TripId", "ArrivalTime", "DepartureTime", "StopId", "StopSequence", "StopHeadsign", "PickupType", "DropOffType", "ShapeDistTraveled", });
      internal__static_GTFSData_Stop__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[4];
      internal__static_GTFSData_Stop__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Stop, global::GTFSData.Types.Stop.Builder>(internal__static_GTFSData_Stop__Descriptor,
              new string[] { "StopId", "StopCode", "StopName", "StopDesc", "StopLat", "StopLon", "ZoneId", "StopUrl", "LocationType", "ParentStation", "StopTimezone", "WheelchairBoarding", });
      internal__static_GTFSData_ShapeSegment__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[5];
      internal__static_GTFSData_ShapeSegment__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.ShapeSegment, global::GTFSData.Types.ShapeSegment.Builder>(internal__static_GTFSData_ShapeSegment__Descriptor,
              new string[] { "ShapePtLat", "ShapePtLon", "ShapeDistTraveled", });
      internal__static_GTFSData_Shape__Descriptor = internal__static_GTFSData__Descriptor.NestedTypes[6];
      internal__static_GTFSData_Shape__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::GTFSData.Types.Shape, global::GTFSData.Types.Shape.Builder>(internal__static_GTFSData_Shape__Descriptor,
              new string[] { "ShapeId", "Shapes", });
      return null;
    };
    pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbd::FileDescriptor[] {
        }, assigner);
  }
  #endregion
  
}
#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class GTFSData : pb::GeneratedMessage<GTFSData, GTFSData.Builder> {
  private GTFSData() { }
  private static readonly GTFSData defaultInstance = new GTFSData().MakeReadOnly();
  private static readonly string[] _gTFSDataFieldNames = new string[] {  };
  private static readonly uint[] _gTFSDataFieldTags = new uint[] {  };
  public static GTFSData DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override GTFSData DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override GTFSData ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Gtfsdata.internal__static_GTFSData__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<GTFSData, GTFSData.Builder> InternalFieldAccessors {
    get { return global::Gtfsdata.internal__static_GTFSData__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    public enum Accessibility {
      NO_INFO = 0,
      ACCESSIBLE = 1,
      NOT_ACCESSIBLE = 2,
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TempListOfStops : pb::GeneratedMessage<TempListOfStops, TempListOfStops.Builder> {
      private TempListOfStops() { }
      private static readonly TempListOfStops defaultInstance = new TempListOfStops().MakeReadOnly();
      private static readonly string[] _tempListOfStopsFieldNames = new string[] { "stops" };
      private static readonly uint[] _tempListOfStopsFieldTags = new uint[] { 10 };
      public static TempListOfStops DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override TempListOfStops DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override TempListOfStops ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_TempListOfStops__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<TempListOfStops, TempListOfStops.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_TempListOfStops__FieldAccessorTable; }
      }
      
      public const int StopsFieldNumber = 1;
      private pbc::PopsicleList<global::GTFSData.Types.Stop> stops_ = new pbc::PopsicleList<global::GTFSData.Types.Stop>();
      public scg::IList<global::GTFSData.Types.Stop> StopsList {
        get { return stops_; }
      }
      public int StopsCount {
        get { return stops_.Count; }
      }
      public global::GTFSData.Types.Stop GetStops(int index) {
        return stops_[index];
      }
      
      public override bool IsInitialized {
        get {
          foreach (global::GTFSData.Types.Stop element in StopsList) {
            if (!element.IsInitialized) return false;
          }
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _tempListOfStopsFieldNames;
        if (stops_.Count > 0) {
          output.WriteMessageArray(1, field_names[0], stops_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          foreach (global::GTFSData.Types.Stop element in StopsList) {
            size += pb::CodedOutputStream.ComputeMessageSize(1, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static TempListOfStops ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static TempListOfStops ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static TempListOfStops ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static TempListOfStops ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static TempListOfStops ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private TempListOfStops MakeReadOnly() {
        stops_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(TempListOfStops prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<TempListOfStops, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(TempListOfStops cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private TempListOfStops result;
        
        private TempListOfStops PrepareBuilder() {
          if (resultIsReadOnly) {
            TempListOfStops original = result;
            result = new TempListOfStops();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override TempListOfStops MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.TempListOfStops.Descriptor; }
        }
        
        public override TempListOfStops DefaultInstanceForType {
          get { return global::GTFSData.Types.TempListOfStops.DefaultInstance; }
        }
        
        public override TempListOfStops BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is TempListOfStops) {
            return MergeFrom((TempListOfStops) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(TempListOfStops other) {
          if (other == global::GTFSData.Types.TempListOfStops.DefaultInstance) return this;
          PrepareBuilder();
          if (other.stops_.Count != 0) {
            result.stops_.Add(other.stops_);
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_tempListOfStopsFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _tempListOfStopsFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                input.ReadMessageArray(tag, field_name, result.stops_, global::GTFSData.Types.Stop.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public pbc::IPopsicleList<global::GTFSData.Types.Stop> StopsList {
          get { return PrepareBuilder().stops_; }
        }
        public int StopsCount {
          get { return result.StopsCount; }
        }
        public global::GTFSData.Types.Stop GetStops(int index) {
          return result.GetStops(index);
        }
        public Builder SetStops(int index, global::GTFSData.Types.Stop value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.stops_[index] = value;
          return this;
        }
        public Builder SetStops(int index, global::GTFSData.Types.Stop.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.stops_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddStops(global::GTFSData.Types.Stop value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.stops_.Add(value);
          return this;
        }
        public Builder AddStops(global::GTFSData.Types.Stop.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.stops_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeStops(scg::IEnumerable<global::GTFSData.Types.Stop> values) {
          PrepareBuilder();
          result.stops_.Add(values);
          return this;
        }
        public Builder ClearStops() {
          PrepareBuilder();
          result.stops_.Clear();
          return this;
        }
      }
      static TempListOfStops() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Route : pb::GeneratedMessage<Route, Route.Builder> {
      private Route() { }
      private static readonly Route defaultInstance = new Route().MakeReadOnly();
      private static readonly string[] _routeFieldNames = new string[] { "agency_id", "route_color", "route_desc", "route_id", "route_long_name", "route_short_name", "route_text_color", "route_type", "route_url", "trips" };
      private static readonly uint[] _routeFieldTags = new uint[] { 18, 66, 42, 10, 34, 26, 74, 48, 58, 82 };
      public static Route DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override Route DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override Route ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_Route__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<Route, Route.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_Route__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        public enum RouteType {
          TRAM_STREETCAR_OR_RAIL = 0,
          SUBWAY_OR_METRO = 1,
          RAIL = 2,
          BUS = 3,
          FERRY = 4,
          CABLE_CAR = 5,
          GONDOLA = 6,
          FUNICULAR = 7,
        }
        
      }
      #endregion
      
      public const int RouteIdFieldNumber = 1;
      private bool hasRouteId;
      private string routeId_ = "";
      public bool HasRouteId {
        get { return hasRouteId; }
      }
      public string RouteId {
        get { return routeId_; }
      }
      
      public const int AgencyIdFieldNumber = 2;
      private bool hasAgencyId;
      private string agencyId_ = "";
      public bool HasAgencyId {
        get { return hasAgencyId; }
      }
      public string AgencyId {
        get { return agencyId_; }
      }
      
      public const int RouteShortNameFieldNumber = 3;
      private bool hasRouteShortName;
      private string routeShortName_ = "";
      public bool HasRouteShortName {
        get { return hasRouteShortName; }
      }
      public string RouteShortName {
        get { return routeShortName_; }
      }
      
      public const int RouteLongNameFieldNumber = 4;
      private bool hasRouteLongName;
      private string routeLongName_ = "";
      public bool HasRouteLongName {
        get { return hasRouteLongName; }
      }
      public string RouteLongName {
        get { return routeLongName_; }
      }
      
      public const int RouteDescFieldNumber = 5;
      private bool hasRouteDesc;
      private string routeDesc_ = "";
      public bool HasRouteDesc {
        get { return hasRouteDesc; }
      }
      public string RouteDesc {
        get { return routeDesc_; }
      }
      
      public const int RouteTypeFieldNumber = 6;
      private bool hasRouteType;
      private global::GTFSData.Types.Route.Types.RouteType routeType_ = global::GTFSData.Types.Route.Types.RouteType.TRAM_STREETCAR_OR_RAIL;
      public bool HasRouteType {
        get { return hasRouteType; }
      }
      public global::GTFSData.Types.Route.Types.RouteType RouteType {
        get { return routeType_; }
      }
      
      public const int RouteUrlFieldNumber = 7;
      private bool hasRouteUrl;
      private string routeUrl_ = "";
      public bool HasRouteUrl {
        get { return hasRouteUrl; }
      }
      public string RouteUrl {
        get { return routeUrl_; }
      }
      
      public const int RouteColorFieldNumber = 8;
      private bool hasRouteColor;
      private string routeColor_ = "";
      public bool HasRouteColor {
        get { return hasRouteColor; }
      }
      public string RouteColor {
        get { return routeColor_; }
      }
      
      public const int RouteTextColorFieldNumber = 9;
      private bool hasRouteTextColor;
      private string routeTextColor_ = "";
      public bool HasRouteTextColor {
        get { return hasRouteTextColor; }
      }
      public string RouteTextColor {
        get { return routeTextColor_; }
      }
      
      public const int TripsFieldNumber = 10;
      private pbc::PopsicleList<global::GTFSData.Types.Trip> trips_ = new pbc::PopsicleList<global::GTFSData.Types.Trip>();
      public scg::IList<global::GTFSData.Types.Trip> TripsList {
        get { return trips_; }
      }
      public int TripsCount {
        get { return trips_.Count; }
      }
      public global::GTFSData.Types.Trip GetTrips(int index) {
        return trips_[index];
      }
      
      public override bool IsInitialized {
        get {
          if (!hasRouteId) return false;
          if (!hasRouteShortName) return false;
          if (!hasRouteLongName) return false;
          if (!hasRouteType) return false;
          foreach (global::GTFSData.Types.Trip element in TripsList) {
            if (!element.IsInitialized) return false;
          }
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _routeFieldNames;
        if (hasRouteId) {
          output.WriteString(1, field_names[3], RouteId);
        }
        if (hasAgencyId) {
          output.WriteString(2, field_names[0], AgencyId);
        }
        if (hasRouteShortName) {
          output.WriteString(3, field_names[5], RouteShortName);
        }
        if (hasRouteLongName) {
          output.WriteString(4, field_names[4], RouteLongName);
        }
        if (hasRouteDesc) {
          output.WriteString(5, field_names[2], RouteDesc);
        }
        if (hasRouteType) {
          output.WriteEnum(6, field_names[7], (int) RouteType, RouteType);
        }
        if (hasRouteUrl) {
          output.WriteString(7, field_names[8], RouteUrl);
        }
        if (hasRouteColor) {
          output.WriteString(8, field_names[1], RouteColor);
        }
        if (hasRouteTextColor) {
          output.WriteString(9, field_names[6], RouteTextColor);
        }
        if (trips_.Count > 0) {
          output.WriteMessageArray(10, field_names[9], trips_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasRouteId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, RouteId);
          }
          if (hasAgencyId) {
            size += pb::CodedOutputStream.ComputeStringSize(2, AgencyId);
          }
          if (hasRouteShortName) {
            size += pb::CodedOutputStream.ComputeStringSize(3, RouteShortName);
          }
          if (hasRouteLongName) {
            size += pb::CodedOutputStream.ComputeStringSize(4, RouteLongName);
          }
          if (hasRouteDesc) {
            size += pb::CodedOutputStream.ComputeStringSize(5, RouteDesc);
          }
          if (hasRouteType) {
            size += pb::CodedOutputStream.ComputeEnumSize(6, (int) RouteType);
          }
          if (hasRouteUrl) {
            size += pb::CodedOutputStream.ComputeStringSize(7, RouteUrl);
          }
          if (hasRouteColor) {
            size += pb::CodedOutputStream.ComputeStringSize(8, RouteColor);
          }
          if (hasRouteTextColor) {
            size += pb::CodedOutputStream.ComputeStringSize(9, RouteTextColor);
          }
          foreach (global::GTFSData.Types.Trip element in TripsList) {
            size += pb::CodedOutputStream.ComputeMessageSize(10, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static Route ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Route ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Route ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Route ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Route ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Route ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static Route ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static Route ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static Route ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Route ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private Route MakeReadOnly() {
        trips_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(Route prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<Route, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(Route cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private Route result;
        
        private Route PrepareBuilder() {
          if (resultIsReadOnly) {
            Route original = result;
            result = new Route();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override Route MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.Route.Descriptor; }
        }
        
        public override Route DefaultInstanceForType {
          get { return global::GTFSData.Types.Route.DefaultInstance; }
        }
        
        public override Route BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is Route) {
            return MergeFrom((Route) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(Route other) {
          if (other == global::GTFSData.Types.Route.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasRouteId) {
            RouteId = other.RouteId;
          }
          if (other.HasAgencyId) {
            AgencyId = other.AgencyId;
          }
          if (other.HasRouteShortName) {
            RouteShortName = other.RouteShortName;
          }
          if (other.HasRouteLongName) {
            RouteLongName = other.RouteLongName;
          }
          if (other.HasRouteDesc) {
            RouteDesc = other.RouteDesc;
          }
          if (other.HasRouteType) {
            RouteType = other.RouteType;
          }
          if (other.HasRouteUrl) {
            RouteUrl = other.RouteUrl;
          }
          if (other.HasRouteColor) {
            RouteColor = other.RouteColor;
          }
          if (other.HasRouteTextColor) {
            RouteTextColor = other.RouteTextColor;
          }
          if (other.trips_.Count != 0) {
            result.trips_.Add(other.trips_);
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_routeFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _routeFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasRouteId = input.ReadString(ref result.routeId_);
                break;
              }
              case 18: {
                result.hasAgencyId = input.ReadString(ref result.agencyId_);
                break;
              }
              case 26: {
                result.hasRouteShortName = input.ReadString(ref result.routeShortName_);
                break;
              }
              case 34: {
                result.hasRouteLongName = input.ReadString(ref result.routeLongName_);
                break;
              }
              case 42: {
                result.hasRouteDesc = input.ReadString(ref result.routeDesc_);
                break;
              }
              case 48: {
                object unknown;
                if(input.ReadEnum(ref result.routeType_, out unknown)) {
                  result.hasRouteType = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(6, (ulong)(int)unknown);
                }
                break;
              }
              case 58: {
                result.hasRouteUrl = input.ReadString(ref result.routeUrl_);
                break;
              }
              case 66: {
                result.hasRouteColor = input.ReadString(ref result.routeColor_);
                break;
              }
              case 74: {
                result.hasRouteTextColor = input.ReadString(ref result.routeTextColor_);
                break;
              }
              case 82: {
                input.ReadMessageArray(tag, field_name, result.trips_, global::GTFSData.Types.Trip.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasRouteId {
          get { return result.hasRouteId; }
        }
        public string RouteId {
          get { return result.RouteId; }
          set { SetRouteId(value); }
        }
        public Builder SetRouteId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteId = true;
          result.routeId_ = value;
          return this;
        }
        public Builder ClearRouteId() {
          PrepareBuilder();
          result.hasRouteId = false;
          result.routeId_ = "";
          return this;
        }
        
        public bool HasAgencyId {
          get { return result.hasAgencyId; }
        }
        public string AgencyId {
          get { return result.AgencyId; }
          set { SetAgencyId(value); }
        }
        public Builder SetAgencyId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasAgencyId = true;
          result.agencyId_ = value;
          return this;
        }
        public Builder ClearAgencyId() {
          PrepareBuilder();
          result.hasAgencyId = false;
          result.agencyId_ = "";
          return this;
        }
        
        public bool HasRouteShortName {
          get { return result.hasRouteShortName; }
        }
        public string RouteShortName {
          get { return result.RouteShortName; }
          set { SetRouteShortName(value); }
        }
        public Builder SetRouteShortName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteShortName = true;
          result.routeShortName_ = value;
          return this;
        }
        public Builder ClearRouteShortName() {
          PrepareBuilder();
          result.hasRouteShortName = false;
          result.routeShortName_ = "";
          return this;
        }
        
        public bool HasRouteLongName {
          get { return result.hasRouteLongName; }
        }
        public string RouteLongName {
          get { return result.RouteLongName; }
          set { SetRouteLongName(value); }
        }
        public Builder SetRouteLongName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteLongName = true;
          result.routeLongName_ = value;
          return this;
        }
        public Builder ClearRouteLongName() {
          PrepareBuilder();
          result.hasRouteLongName = false;
          result.routeLongName_ = "";
          return this;
        }
        
        public bool HasRouteDesc {
          get { return result.hasRouteDesc; }
        }
        public string RouteDesc {
          get { return result.RouteDesc; }
          set { SetRouteDesc(value); }
        }
        public Builder SetRouteDesc(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteDesc = true;
          result.routeDesc_ = value;
          return this;
        }
        public Builder ClearRouteDesc() {
          PrepareBuilder();
          result.hasRouteDesc = false;
          result.routeDesc_ = "";
          return this;
        }
        
        public bool HasRouteType {
         get { return result.hasRouteType; }
        }
        public global::GTFSData.Types.Route.Types.RouteType RouteType {
          get { return result.RouteType; }
          set { SetRouteType(value); }
        }
        public Builder SetRouteType(global::GTFSData.Types.Route.Types.RouteType value) {
          PrepareBuilder();
          result.hasRouteType = true;
          result.routeType_ = value;
          return this;
        }
        public Builder ClearRouteType() {
          PrepareBuilder();
          result.hasRouteType = false;
          result.routeType_ = global::GTFSData.Types.Route.Types.RouteType.TRAM_STREETCAR_OR_RAIL;
          return this;
        }
        
        public bool HasRouteUrl {
          get { return result.hasRouteUrl; }
        }
        public string RouteUrl {
          get { return result.RouteUrl; }
          set { SetRouteUrl(value); }
        }
        public Builder SetRouteUrl(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteUrl = true;
          result.routeUrl_ = value;
          return this;
        }
        public Builder ClearRouteUrl() {
          PrepareBuilder();
          result.hasRouteUrl = false;
          result.routeUrl_ = "";
          return this;
        }
        
        public bool HasRouteColor {
          get { return result.hasRouteColor; }
        }
        public string RouteColor {
          get { return result.RouteColor; }
          set { SetRouteColor(value); }
        }
        public Builder SetRouteColor(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteColor = true;
          result.routeColor_ = value;
          return this;
        }
        public Builder ClearRouteColor() {
          PrepareBuilder();
          result.hasRouteColor = false;
          result.routeColor_ = "";
          return this;
        }
        
        public bool HasRouteTextColor {
          get { return result.hasRouteTextColor; }
        }
        public string RouteTextColor {
          get { return result.RouteTextColor; }
          set { SetRouteTextColor(value); }
        }
        public Builder SetRouteTextColor(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteTextColor = true;
          result.routeTextColor_ = value;
          return this;
        }
        public Builder ClearRouteTextColor() {
          PrepareBuilder();
          result.hasRouteTextColor = false;
          result.routeTextColor_ = "";
          return this;
        }
        
        public pbc::IPopsicleList<global::GTFSData.Types.Trip> TripsList {
          get { return PrepareBuilder().trips_; }
        }
        public int TripsCount {
          get { return result.TripsCount; }
        }
        public global::GTFSData.Types.Trip GetTrips(int index) {
          return result.GetTrips(index);
        }
        public Builder SetTrips(int index, global::GTFSData.Types.Trip value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.trips_[index] = value;
          return this;
        }
        public Builder SetTrips(int index, global::GTFSData.Types.Trip.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.trips_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddTrips(global::GTFSData.Types.Trip value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.trips_.Add(value);
          return this;
        }
        public Builder AddTrips(global::GTFSData.Types.Trip.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.trips_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeTrips(scg::IEnumerable<global::GTFSData.Types.Trip> values) {
          PrepareBuilder();
          result.trips_.Add(values);
          return this;
        }
        public Builder ClearTrips() {
          PrepareBuilder();
          result.trips_.Clear();
          return this;
        }
      }
      static Route() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Trip : pb::GeneratedMessage<Trip, Trip.Builder> {
      private Trip() { }
      private static readonly Trip defaultInstance = new Trip().MakeReadOnly();
      private static readonly string[] _tripFieldNames = new string[] { "bikes_allowed", "block_id", "direction_id", "route_id", "service_id", "stopTimes", "tripShape", "trip_id", "trip_short_name", "wheelchair_accessible" };
      private static readonly uint[] _tripFieldTags = new uint[] { 72, 50, 40, 10, 18, 82, 58, 26, 34, 64 };
      public static Trip DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override Trip DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override Trip ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_Trip__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<Trip, Trip.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_Trip__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        public enum Direction {
          DIRECTION_ZERO = 0,
          DIRECTION_ONE = 1,
        }
        
      }
      #endregion
      
      public const int RouteIdFieldNumber = 1;
      private bool hasRouteId;
      private string routeId_ = "";
      public bool HasRouteId {
        get { return hasRouteId; }
      }
      public string RouteId {
        get { return routeId_; }
      }
      
      public const int ServiceIdFieldNumber = 2;
      private bool hasServiceId;
      private string serviceId_ = "";
      public bool HasServiceId {
        get { return hasServiceId; }
      }
      public string ServiceId {
        get { return serviceId_; }
      }
      
      public const int TripIdFieldNumber = 3;
      private bool hasTripId;
      private string tripId_ = "";
      public bool HasTripId {
        get { return hasTripId; }
      }
      public string TripId {
        get { return tripId_; }
      }
      
      public const int TripShortNameFieldNumber = 4;
      private bool hasTripShortName;
      private string tripShortName_ = "";
      public bool HasTripShortName {
        get { return hasTripShortName; }
      }
      public string TripShortName {
        get { return tripShortName_; }
      }
      
      public const int DirectionIdFieldNumber = 5;
      private bool hasDirectionId;
      private global::GTFSData.Types.Trip.Types.Direction directionId_ = global::GTFSData.Types.Trip.Types.Direction.DIRECTION_ZERO;
      public bool HasDirectionId {
        get { return hasDirectionId; }
      }
      public global::GTFSData.Types.Trip.Types.Direction DirectionId {
        get { return directionId_; }
      }
      
      public const int BlockIdFieldNumber = 6;
      private bool hasBlockId;
      private string blockId_ = "";
      public bool HasBlockId {
        get { return hasBlockId; }
      }
      public string BlockId {
        get { return blockId_; }
      }
      
      public const int TripShapeFieldNumber = 7;
      private bool hasTripShape;
      private global::GTFSData.Types.Shape tripShape_;
      public bool HasTripShape {
        get { return hasTripShape; }
      }
      public global::GTFSData.Types.Shape TripShape {
        get { return tripShape_ ?? global::GTFSData.Types.Shape.DefaultInstance; }
      }
      
      public const int WheelchairAccessibleFieldNumber = 8;
      private bool hasWheelchairAccessible;
      private global::GTFSData.Types.Accessibility wheelchairAccessible_ = global::GTFSData.Types.Accessibility.NO_INFO;
      public bool HasWheelchairAccessible {
        get { return hasWheelchairAccessible; }
      }
      public global::GTFSData.Types.Accessibility WheelchairAccessible {
        get { return wheelchairAccessible_; }
      }
      
      public const int BikesAllowedFieldNumber = 9;
      private bool hasBikesAllowed;
      private global::GTFSData.Types.Accessibility bikesAllowed_ = global::GTFSData.Types.Accessibility.NO_INFO;
      public bool HasBikesAllowed {
        get { return hasBikesAllowed; }
      }
      public global::GTFSData.Types.Accessibility BikesAllowed {
        get { return bikesAllowed_; }
      }
      
      public const int StopTimesFieldNumber = 10;
      private pbc::PopsicleList<global::GTFSData.Types.StopTime> stopTimes_ = new pbc::PopsicleList<global::GTFSData.Types.StopTime>();
      public scg::IList<global::GTFSData.Types.StopTime> StopTimesList {
        get { return stopTimes_; }
      }
      public int StopTimesCount {
        get { return stopTimes_.Count; }
      }
      public global::GTFSData.Types.StopTime GetStopTimes(int index) {
        return stopTimes_[index];
      }
      
      public override bool IsInitialized {
        get {
          if (!hasRouteId) return false;
          if (!hasServiceId) return false;
          if (!hasTripId) return false;
          if (HasTripShape) {
            if (!TripShape.IsInitialized) return false;
          }
          foreach (global::GTFSData.Types.StopTime element in StopTimesList) {
            if (!element.IsInitialized) return false;
          }
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _tripFieldNames;
        if (hasRouteId) {
          output.WriteString(1, field_names[3], RouteId);
        }
        if (hasServiceId) {
          output.WriteString(2, field_names[4], ServiceId);
        }
        if (hasTripId) {
          output.WriteString(3, field_names[7], TripId);
        }
        if (hasTripShortName) {
          output.WriteString(4, field_names[8], TripShortName);
        }
        if (hasDirectionId) {
          output.WriteEnum(5, field_names[2], (int) DirectionId, DirectionId);
        }
        if (hasBlockId) {
          output.WriteString(6, field_names[1], BlockId);
        }
        if (hasTripShape) {
          output.WriteMessage(7, field_names[6], TripShape);
        }
        if (hasWheelchairAccessible) {
          output.WriteEnum(8, field_names[9], (int) WheelchairAccessible, WheelchairAccessible);
        }
        if (hasBikesAllowed) {
          output.WriteEnum(9, field_names[0], (int) BikesAllowed, BikesAllowed);
        }
        if (stopTimes_.Count > 0) {
          output.WriteMessageArray(10, field_names[5], stopTimes_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasRouteId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, RouteId);
          }
          if (hasServiceId) {
            size += pb::CodedOutputStream.ComputeStringSize(2, ServiceId);
          }
          if (hasTripId) {
            size += pb::CodedOutputStream.ComputeStringSize(3, TripId);
          }
          if (hasTripShortName) {
            size += pb::CodedOutputStream.ComputeStringSize(4, TripShortName);
          }
          if (hasDirectionId) {
            size += pb::CodedOutputStream.ComputeEnumSize(5, (int) DirectionId);
          }
          if (hasBlockId) {
            size += pb::CodedOutputStream.ComputeStringSize(6, BlockId);
          }
          if (hasTripShape) {
            size += pb::CodedOutputStream.ComputeMessageSize(7, TripShape);
          }
          if (hasWheelchairAccessible) {
            size += pb::CodedOutputStream.ComputeEnumSize(8, (int) WheelchairAccessible);
          }
          if (hasBikesAllowed) {
            size += pb::CodedOutputStream.ComputeEnumSize(9, (int) BikesAllowed);
          }
          foreach (global::GTFSData.Types.StopTime element in StopTimesList) {
            size += pb::CodedOutputStream.ComputeMessageSize(10, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static Trip ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Trip ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Trip ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Trip ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Trip ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Trip ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static Trip ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static Trip ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static Trip ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Trip ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private Trip MakeReadOnly() {
        stopTimes_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(Trip prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<Trip, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(Trip cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private Trip result;
        
        private Trip PrepareBuilder() {
          if (resultIsReadOnly) {
            Trip original = result;
            result = new Trip();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override Trip MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.Trip.Descriptor; }
        }
        
        public override Trip DefaultInstanceForType {
          get { return global::GTFSData.Types.Trip.DefaultInstance; }
        }
        
        public override Trip BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is Trip) {
            return MergeFrom((Trip) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(Trip other) {
          if (other == global::GTFSData.Types.Trip.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasRouteId) {
            RouteId = other.RouteId;
          }
          if (other.HasServiceId) {
            ServiceId = other.ServiceId;
          }
          if (other.HasTripId) {
            TripId = other.TripId;
          }
          if (other.HasTripShortName) {
            TripShortName = other.TripShortName;
          }
          if (other.HasDirectionId) {
            DirectionId = other.DirectionId;
          }
          if (other.HasBlockId) {
            BlockId = other.BlockId;
          }
          if (other.HasTripShape) {
            MergeTripShape(other.TripShape);
          }
          if (other.HasWheelchairAccessible) {
            WheelchairAccessible = other.WheelchairAccessible;
          }
          if (other.HasBikesAllowed) {
            BikesAllowed = other.BikesAllowed;
          }
          if (other.stopTimes_.Count != 0) {
            result.stopTimes_.Add(other.stopTimes_);
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_tripFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _tripFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasRouteId = input.ReadString(ref result.routeId_);
                break;
              }
              case 18: {
                result.hasServiceId = input.ReadString(ref result.serviceId_);
                break;
              }
              case 26: {
                result.hasTripId = input.ReadString(ref result.tripId_);
                break;
              }
              case 34: {
                result.hasTripShortName = input.ReadString(ref result.tripShortName_);
                break;
              }
              case 40: {
                object unknown;
                if(input.ReadEnum(ref result.directionId_, out unknown)) {
                  result.hasDirectionId = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(5, (ulong)(int)unknown);
                }
                break;
              }
              case 50: {
                result.hasBlockId = input.ReadString(ref result.blockId_);
                break;
              }
              case 58: {
                global::GTFSData.Types.Shape.Builder subBuilder = global::GTFSData.Types.Shape.CreateBuilder();
                if (result.hasTripShape) {
                  subBuilder.MergeFrom(TripShape);
                }
                input.ReadMessage(subBuilder, extensionRegistry);
                TripShape = subBuilder.BuildPartial();
                break;
              }
              case 64: {
                object unknown;
                if(input.ReadEnum(ref result.wheelchairAccessible_, out unknown)) {
                  result.hasWheelchairAccessible = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(8, (ulong)(int)unknown);
                }
                break;
              }
              case 72: {
                object unknown;
                if(input.ReadEnum(ref result.bikesAllowed_, out unknown)) {
                  result.hasBikesAllowed = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(9, (ulong)(int)unknown);
                }
                break;
              }
              case 82: {
                input.ReadMessageArray(tag, field_name, result.stopTimes_, global::GTFSData.Types.StopTime.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasRouteId {
          get { return result.hasRouteId; }
        }
        public string RouteId {
          get { return result.RouteId; }
          set { SetRouteId(value); }
        }
        public Builder SetRouteId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasRouteId = true;
          result.routeId_ = value;
          return this;
        }
        public Builder ClearRouteId() {
          PrepareBuilder();
          result.hasRouteId = false;
          result.routeId_ = "";
          return this;
        }
        
        public bool HasServiceId {
          get { return result.hasServiceId; }
        }
        public string ServiceId {
          get { return result.ServiceId; }
          set { SetServiceId(value); }
        }
        public Builder SetServiceId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasServiceId = true;
          result.serviceId_ = value;
          return this;
        }
        public Builder ClearServiceId() {
          PrepareBuilder();
          result.hasServiceId = false;
          result.serviceId_ = "";
          return this;
        }
        
        public bool HasTripId {
          get { return result.hasTripId; }
        }
        public string TripId {
          get { return result.TripId; }
          set { SetTripId(value); }
        }
        public Builder SetTripId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasTripId = true;
          result.tripId_ = value;
          return this;
        }
        public Builder ClearTripId() {
          PrepareBuilder();
          result.hasTripId = false;
          result.tripId_ = "";
          return this;
        }
        
        public bool HasTripShortName {
          get { return result.hasTripShortName; }
        }
        public string TripShortName {
          get { return result.TripShortName; }
          set { SetTripShortName(value); }
        }
        public Builder SetTripShortName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasTripShortName = true;
          result.tripShortName_ = value;
          return this;
        }
        public Builder ClearTripShortName() {
          PrepareBuilder();
          result.hasTripShortName = false;
          result.tripShortName_ = "";
          return this;
        }
        
        public bool HasDirectionId {
         get { return result.hasDirectionId; }
        }
        public global::GTFSData.Types.Trip.Types.Direction DirectionId {
          get { return result.DirectionId; }
          set { SetDirectionId(value); }
        }
        public Builder SetDirectionId(global::GTFSData.Types.Trip.Types.Direction value) {
          PrepareBuilder();
          result.hasDirectionId = true;
          result.directionId_ = value;
          return this;
        }
        public Builder ClearDirectionId() {
          PrepareBuilder();
          result.hasDirectionId = false;
          result.directionId_ = global::GTFSData.Types.Trip.Types.Direction.DIRECTION_ZERO;
          return this;
        }
        
        public bool HasBlockId {
          get { return result.hasBlockId; }
        }
        public string BlockId {
          get { return result.BlockId; }
          set { SetBlockId(value); }
        }
        public Builder SetBlockId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasBlockId = true;
          result.blockId_ = value;
          return this;
        }
        public Builder ClearBlockId() {
          PrepareBuilder();
          result.hasBlockId = false;
          result.blockId_ = "";
          return this;
        }
        
        public bool HasTripShape {
         get { return result.hasTripShape; }
        }
        public global::GTFSData.Types.Shape TripShape {
          get { return result.TripShape; }
          set { SetTripShape(value); }
        }
        public Builder SetTripShape(global::GTFSData.Types.Shape value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasTripShape = true;
          result.tripShape_ = value;
          return this;
        }
        public Builder SetTripShape(global::GTFSData.Types.Shape.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.hasTripShape = true;
          result.tripShape_ = builderForValue.Build();
          return this;
        }
        public Builder MergeTripShape(global::GTFSData.Types.Shape value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          if (result.hasTripShape &&
              result.tripShape_ != global::GTFSData.Types.Shape.DefaultInstance) {
              result.tripShape_ = global::GTFSData.Types.Shape.CreateBuilder(result.tripShape_).MergeFrom(value).BuildPartial();
          } else {
            result.tripShape_ = value;
          }
          result.hasTripShape = true;
          return this;
        }
        public Builder ClearTripShape() {
          PrepareBuilder();
          result.hasTripShape = false;
          result.tripShape_ = null;
          return this;
        }
        
        public bool HasWheelchairAccessible {
         get { return result.hasWheelchairAccessible; }
        }
        public global::GTFSData.Types.Accessibility WheelchairAccessible {
          get { return result.WheelchairAccessible; }
          set { SetWheelchairAccessible(value); }
        }
        public Builder SetWheelchairAccessible(global::GTFSData.Types.Accessibility value) {
          PrepareBuilder();
          result.hasWheelchairAccessible = true;
          result.wheelchairAccessible_ = value;
          return this;
        }
        public Builder ClearWheelchairAccessible() {
          PrepareBuilder();
          result.hasWheelchairAccessible = false;
          result.wheelchairAccessible_ = global::GTFSData.Types.Accessibility.NO_INFO;
          return this;
        }
        
        public bool HasBikesAllowed {
         get { return result.hasBikesAllowed; }
        }
        public global::GTFSData.Types.Accessibility BikesAllowed {
          get { return result.BikesAllowed; }
          set { SetBikesAllowed(value); }
        }
        public Builder SetBikesAllowed(global::GTFSData.Types.Accessibility value) {
          PrepareBuilder();
          result.hasBikesAllowed = true;
          result.bikesAllowed_ = value;
          return this;
        }
        public Builder ClearBikesAllowed() {
          PrepareBuilder();
          result.hasBikesAllowed = false;
          result.bikesAllowed_ = global::GTFSData.Types.Accessibility.NO_INFO;
          return this;
        }
        
        public pbc::IPopsicleList<global::GTFSData.Types.StopTime> StopTimesList {
          get { return PrepareBuilder().stopTimes_; }
        }
        public int StopTimesCount {
          get { return result.StopTimesCount; }
        }
        public global::GTFSData.Types.StopTime GetStopTimes(int index) {
          return result.GetStopTimes(index);
        }
        public Builder SetStopTimes(int index, global::GTFSData.Types.StopTime value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.stopTimes_[index] = value;
          return this;
        }
        public Builder SetStopTimes(int index, global::GTFSData.Types.StopTime.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.stopTimes_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddStopTimes(global::GTFSData.Types.StopTime value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.stopTimes_.Add(value);
          return this;
        }
        public Builder AddStopTimes(global::GTFSData.Types.StopTime.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.stopTimes_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeStopTimes(scg::IEnumerable<global::GTFSData.Types.StopTime> values) {
          PrepareBuilder();
          result.stopTimes_.Add(values);
          return this;
        }
        public Builder ClearStopTimes() {
          PrepareBuilder();
          result.stopTimes_.Clear();
          return this;
        }
      }
      static Trip() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class StopTime : pb::GeneratedMessage<StopTime, StopTime.Builder> {
      private StopTime() { }
      private static readonly StopTime defaultInstance = new StopTime().MakeReadOnly();
      private static readonly string[] _stopTimeFieldNames = new string[] { "arrival_time", "departure_time", "drop_off_type", "pickup_type", "shape_dist_traveled", "stop_headsign", "stop_id", "stop_sequence", "trip_id" };
      private static readonly uint[] _stopTimeFieldTags = new uint[] { 18, 26, 64, 56, 77, 50, 34, 40, 10 };
      public static StopTime DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override StopTime DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override StopTime ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_StopTime__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<StopTime, StopTime.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_StopTime__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        public enum PickupDropoffType {
          REGULARLY_SCHEDULED = 0,
          NO_PICKUP_AVAILABLE = 1,
          MUST_PHONE_AGENCY = 2,
          COORDINATE_WITH_DRIVER = 3,
        }
        
      }
      #endregion
      
      public const int TripIdFieldNumber = 1;
      private bool hasTripId;
      private string tripId_ = "";
      public bool HasTripId {
        get { return hasTripId; }
      }
      public string TripId {
        get { return tripId_; }
      }
      
      public const int ArrivalTimeFieldNumber = 2;
      private bool hasArrivalTime;
      private string arrivalTime_ = "";
      public bool HasArrivalTime {
        get { return hasArrivalTime; }
      }
      public string ArrivalTime {
        get { return arrivalTime_; }
      }
      
      public const int DepartureTimeFieldNumber = 3;
      private bool hasDepartureTime;
      private string departureTime_ = "";
      public bool HasDepartureTime {
        get { return hasDepartureTime; }
      }
      public string DepartureTime {
        get { return departureTime_; }
      }
      
      public const int StopIdFieldNumber = 4;
      private bool hasStopId;
      private string stopId_ = "";
      public bool HasStopId {
        get { return hasStopId; }
      }
      public string StopId {
        get { return stopId_; }
      }
      
      public const int StopSequenceFieldNumber = 5;
      private bool hasStopSequence;
      private uint stopSequence_;
      public bool HasStopSequence {
        get { return hasStopSequence; }
      }
      [global::System.CLSCompliant(false)]
      public uint StopSequence {
        get { return stopSequence_; }
      }
      
      public const int StopHeadsignFieldNumber = 6;
      private bool hasStopHeadsign;
      private string stopHeadsign_ = "";
      public bool HasStopHeadsign {
        get { return hasStopHeadsign; }
      }
      public string StopHeadsign {
        get { return stopHeadsign_; }
      }
      
      public const int PickupTypeFieldNumber = 7;
      private bool hasPickupType;
      private global::GTFSData.Types.StopTime.Types.PickupDropoffType pickupType_ = global::GTFSData.Types.StopTime.Types.PickupDropoffType.REGULARLY_SCHEDULED;
      public bool HasPickupType {
        get { return hasPickupType; }
      }
      public global::GTFSData.Types.StopTime.Types.PickupDropoffType PickupType {
        get { return pickupType_; }
      }
      
      public const int DropOffTypeFieldNumber = 8;
      private bool hasDropOffType;
      private global::GTFSData.Types.StopTime.Types.PickupDropoffType dropOffType_ = global::GTFSData.Types.StopTime.Types.PickupDropoffType.REGULARLY_SCHEDULED;
      public bool HasDropOffType {
        get { return hasDropOffType; }
      }
      public global::GTFSData.Types.StopTime.Types.PickupDropoffType DropOffType {
        get { return dropOffType_; }
      }
      
      public const int ShapeDistTraveledFieldNumber = 9;
      private bool hasShapeDistTraveled;
      private float shapeDistTraveled_;
      public bool HasShapeDistTraveled {
        get { return hasShapeDistTraveled; }
      }
      public float ShapeDistTraveled {
        get { return shapeDistTraveled_; }
      }
      
      public override bool IsInitialized {
        get {
          if (!hasTripId) return false;
          if (!hasArrivalTime) return false;
          if (!hasDepartureTime) return false;
          if (!hasStopId) return false;
          if (!hasStopSequence) return false;
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _stopTimeFieldNames;
        if (hasTripId) {
          output.WriteString(1, field_names[8], TripId);
        }
        if (hasArrivalTime) {
          output.WriteString(2, field_names[0], ArrivalTime);
        }
        if (hasDepartureTime) {
          output.WriteString(3, field_names[1], DepartureTime);
        }
        if (hasStopId) {
          output.WriteString(4, field_names[6], StopId);
        }
        if (hasStopSequence) {
          output.WriteUInt32(5, field_names[7], StopSequence);
        }
        if (hasStopHeadsign) {
          output.WriteString(6, field_names[5], StopHeadsign);
        }
        if (hasPickupType) {
          output.WriteEnum(7, field_names[3], (int) PickupType, PickupType);
        }
        if (hasDropOffType) {
          output.WriteEnum(8, field_names[2], (int) DropOffType, DropOffType);
        }
        if (hasShapeDistTraveled) {
          output.WriteFloat(9, field_names[4], ShapeDistTraveled);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasTripId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, TripId);
          }
          if (hasArrivalTime) {
            size += pb::CodedOutputStream.ComputeStringSize(2, ArrivalTime);
          }
          if (hasDepartureTime) {
            size += pb::CodedOutputStream.ComputeStringSize(3, DepartureTime);
          }
          if (hasStopId) {
            size += pb::CodedOutputStream.ComputeStringSize(4, StopId);
          }
          if (hasStopSequence) {
            size += pb::CodedOutputStream.ComputeUInt32Size(5, StopSequence);
          }
          if (hasStopHeadsign) {
            size += pb::CodedOutputStream.ComputeStringSize(6, StopHeadsign);
          }
          if (hasPickupType) {
            size += pb::CodedOutputStream.ComputeEnumSize(7, (int) PickupType);
          }
          if (hasDropOffType) {
            size += pb::CodedOutputStream.ComputeEnumSize(8, (int) DropOffType);
          }
          if (hasShapeDistTraveled) {
            size += pb::CodedOutputStream.ComputeFloatSize(9, ShapeDistTraveled);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static StopTime ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static StopTime ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static StopTime ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static StopTime ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static StopTime ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static StopTime ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static StopTime ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static StopTime ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static StopTime ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static StopTime ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private StopTime MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(StopTime prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<StopTime, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(StopTime cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private StopTime result;
        
        private StopTime PrepareBuilder() {
          if (resultIsReadOnly) {
            StopTime original = result;
            result = new StopTime();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override StopTime MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.StopTime.Descriptor; }
        }
        
        public override StopTime DefaultInstanceForType {
          get { return global::GTFSData.Types.StopTime.DefaultInstance; }
        }
        
        public override StopTime BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is StopTime) {
            return MergeFrom((StopTime) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(StopTime other) {
          if (other == global::GTFSData.Types.StopTime.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasTripId) {
            TripId = other.TripId;
          }
          if (other.HasArrivalTime) {
            ArrivalTime = other.ArrivalTime;
          }
          if (other.HasDepartureTime) {
            DepartureTime = other.DepartureTime;
          }
          if (other.HasStopId) {
            StopId = other.StopId;
          }
          if (other.HasStopSequence) {
            StopSequence = other.StopSequence;
          }
          if (other.HasStopHeadsign) {
            StopHeadsign = other.StopHeadsign;
          }
          if (other.HasPickupType) {
            PickupType = other.PickupType;
          }
          if (other.HasDropOffType) {
            DropOffType = other.DropOffType;
          }
          if (other.HasShapeDistTraveled) {
            ShapeDistTraveled = other.ShapeDistTraveled;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_stopTimeFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _stopTimeFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasTripId = input.ReadString(ref result.tripId_);
                break;
              }
              case 18: {
                result.hasArrivalTime = input.ReadString(ref result.arrivalTime_);
                break;
              }
              case 26: {
                result.hasDepartureTime = input.ReadString(ref result.departureTime_);
                break;
              }
              case 34: {
                result.hasStopId = input.ReadString(ref result.stopId_);
                break;
              }
              case 40: {
                result.hasStopSequence = input.ReadUInt32(ref result.stopSequence_);
                break;
              }
              case 50: {
                result.hasStopHeadsign = input.ReadString(ref result.stopHeadsign_);
                break;
              }
              case 56: {
                object unknown;
                if(input.ReadEnum(ref result.pickupType_, out unknown)) {
                  result.hasPickupType = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(7, (ulong)(int)unknown);
                }
                break;
              }
              case 64: {
                object unknown;
                if(input.ReadEnum(ref result.dropOffType_, out unknown)) {
                  result.hasDropOffType = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(8, (ulong)(int)unknown);
                }
                break;
              }
              case 77: {
                result.hasShapeDistTraveled = input.ReadFloat(ref result.shapeDistTraveled_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasTripId {
          get { return result.hasTripId; }
        }
        public string TripId {
          get { return result.TripId; }
          set { SetTripId(value); }
        }
        public Builder SetTripId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasTripId = true;
          result.tripId_ = value;
          return this;
        }
        public Builder ClearTripId() {
          PrepareBuilder();
          result.hasTripId = false;
          result.tripId_ = "";
          return this;
        }
        
        public bool HasArrivalTime {
          get { return result.hasArrivalTime; }
        }
        public string ArrivalTime {
          get { return result.ArrivalTime; }
          set { SetArrivalTime(value); }
        }
        public Builder SetArrivalTime(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasArrivalTime = true;
          result.arrivalTime_ = value;
          return this;
        }
        public Builder ClearArrivalTime() {
          PrepareBuilder();
          result.hasArrivalTime = false;
          result.arrivalTime_ = "";
          return this;
        }
        
        public bool HasDepartureTime {
          get { return result.hasDepartureTime; }
        }
        public string DepartureTime {
          get { return result.DepartureTime; }
          set { SetDepartureTime(value); }
        }
        public Builder SetDepartureTime(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasDepartureTime = true;
          result.departureTime_ = value;
          return this;
        }
        public Builder ClearDepartureTime() {
          PrepareBuilder();
          result.hasDepartureTime = false;
          result.departureTime_ = "";
          return this;
        }
        
        public bool HasStopId {
          get { return result.hasStopId; }
        }
        public string StopId {
          get { return result.StopId; }
          set { SetStopId(value); }
        }
        public Builder SetStopId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopId = true;
          result.stopId_ = value;
          return this;
        }
        public Builder ClearStopId() {
          PrepareBuilder();
          result.hasStopId = false;
          result.stopId_ = "";
          return this;
        }
        
        public bool HasStopSequence {
          get { return result.hasStopSequence; }
        }
        [global::System.CLSCompliant(false)]
        public uint StopSequence {
          get { return result.StopSequence; }
          set { SetStopSequence(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetStopSequence(uint value) {
          PrepareBuilder();
          result.hasStopSequence = true;
          result.stopSequence_ = value;
          return this;
        }
        public Builder ClearStopSequence() {
          PrepareBuilder();
          result.hasStopSequence = false;
          result.stopSequence_ = 0;
          return this;
        }
        
        public bool HasStopHeadsign {
          get { return result.hasStopHeadsign; }
        }
        public string StopHeadsign {
          get { return result.StopHeadsign; }
          set { SetStopHeadsign(value); }
        }
        public Builder SetStopHeadsign(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopHeadsign = true;
          result.stopHeadsign_ = value;
          return this;
        }
        public Builder ClearStopHeadsign() {
          PrepareBuilder();
          result.hasStopHeadsign = false;
          result.stopHeadsign_ = "";
          return this;
        }
        
        public bool HasPickupType {
         get { return result.hasPickupType; }
        }
        public global::GTFSData.Types.StopTime.Types.PickupDropoffType PickupType {
          get { return result.PickupType; }
          set { SetPickupType(value); }
        }
        public Builder SetPickupType(global::GTFSData.Types.StopTime.Types.PickupDropoffType value) {
          PrepareBuilder();
          result.hasPickupType = true;
          result.pickupType_ = value;
          return this;
        }
        public Builder ClearPickupType() {
          PrepareBuilder();
          result.hasPickupType = false;
          result.pickupType_ = global::GTFSData.Types.StopTime.Types.PickupDropoffType.REGULARLY_SCHEDULED;
          return this;
        }
        
        public bool HasDropOffType {
         get { return result.hasDropOffType; }
        }
        public global::GTFSData.Types.StopTime.Types.PickupDropoffType DropOffType {
          get { return result.DropOffType; }
          set { SetDropOffType(value); }
        }
        public Builder SetDropOffType(global::GTFSData.Types.StopTime.Types.PickupDropoffType value) {
          PrepareBuilder();
          result.hasDropOffType = true;
          result.dropOffType_ = value;
          return this;
        }
        public Builder ClearDropOffType() {
          PrepareBuilder();
          result.hasDropOffType = false;
          result.dropOffType_ = global::GTFSData.Types.StopTime.Types.PickupDropoffType.REGULARLY_SCHEDULED;
          return this;
        }
        
        public bool HasShapeDistTraveled {
          get { return result.hasShapeDistTraveled; }
        }
        public float ShapeDistTraveled {
          get { return result.ShapeDistTraveled; }
          set { SetShapeDistTraveled(value); }
        }
        public Builder SetShapeDistTraveled(float value) {
          PrepareBuilder();
          result.hasShapeDistTraveled = true;
          result.shapeDistTraveled_ = value;
          return this;
        }
        public Builder ClearShapeDistTraveled() {
          PrepareBuilder();
          result.hasShapeDistTraveled = false;
          result.shapeDistTraveled_ = 0F;
          return this;
        }
      }
      static StopTime() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Stop : pb::GeneratedMessage<Stop, Stop.Builder> {
      private Stop() { }
      private static readonly Stop defaultInstance = new Stop().MakeReadOnly();
      private static readonly string[] _stopFieldNames = new string[] { "location_type", "parent_station", "stop_code", "stop_desc", "stop_id", "stop_lat", "stop_lon", "stop_name", "stop_timezone", "stop_url", "wheelchair_boarding", "zone_id" };
      private static readonly uint[] _stopFieldTags = new uint[] { 80, 90, 18, 34, 10, 50, 58, 26, 98, 74, 104, 66 };
      public static Stop DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override Stop DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override Stop ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_Stop__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<Stop, Stop.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_Stop__FieldAccessorTable; }
      }
      
      #region Nested types
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public static partial class Types {
        public enum LocationType {
          STOP = 0,
          STATION = 1,
        }
        
      }
      #endregion
      
      public const int StopIdFieldNumber = 1;
      private bool hasStopId;
      private string stopId_ = "";
      public bool HasStopId {
        get { return hasStopId; }
      }
      public string StopId {
        get { return stopId_; }
      }
      
      public const int StopCodeFieldNumber = 2;
      private bool hasStopCode;
      private string stopCode_ = "";
      public bool HasStopCode {
        get { return hasStopCode; }
      }
      public string StopCode {
        get { return stopCode_; }
      }
      
      public const int StopNameFieldNumber = 3;
      private bool hasStopName;
      private string stopName_ = "";
      public bool HasStopName {
        get { return hasStopName; }
      }
      public string StopName {
        get { return stopName_; }
      }
      
      public const int StopDescFieldNumber = 4;
      private bool hasStopDesc;
      private string stopDesc_ = "";
      public bool HasStopDesc {
        get { return hasStopDesc; }
      }
      public string StopDesc {
        get { return stopDesc_; }
      }
      
      public const int StopLatFieldNumber = 6;
      private bool hasStopLat;
      private string stopLat_ = "";
      public bool HasStopLat {
        get { return hasStopLat; }
      }
      public string StopLat {
        get { return stopLat_; }
      }
      
      public const int StopLonFieldNumber = 7;
      private bool hasStopLon;
      private string stopLon_ = "";
      public bool HasStopLon {
        get { return hasStopLon; }
      }
      public string StopLon {
        get { return stopLon_; }
      }
      
      public const int ZoneIdFieldNumber = 8;
      private bool hasZoneId;
      private string zoneId_ = "";
      public bool HasZoneId {
        get { return hasZoneId; }
      }
      public string ZoneId {
        get { return zoneId_; }
      }
      
      public const int StopUrlFieldNumber = 9;
      private bool hasStopUrl;
      private string stopUrl_ = "";
      public bool HasStopUrl {
        get { return hasStopUrl; }
      }
      public string StopUrl {
        get { return stopUrl_; }
      }
      
      public const int LocationTypeFieldNumber = 10;
      private bool hasLocationType;
      private global::GTFSData.Types.Stop.Types.LocationType locationType_ = global::GTFSData.Types.Stop.Types.LocationType.STOP;
      public bool HasLocationType {
        get { return hasLocationType; }
      }
      public global::GTFSData.Types.Stop.Types.LocationType LocationType {
        get { return locationType_; }
      }
      
      public const int ParentStationFieldNumber = 11;
      private bool hasParentStation;
      private string parentStation_ = "";
      public bool HasParentStation {
        get { return hasParentStation; }
      }
      public string ParentStation {
        get { return parentStation_; }
      }
      
      public const int StopTimezoneFieldNumber = 12;
      private bool hasStopTimezone;
      private string stopTimezone_ = "";
      public bool HasStopTimezone {
        get { return hasStopTimezone; }
      }
      public string StopTimezone {
        get { return stopTimezone_; }
      }
      
      public const int WheelchairBoardingFieldNumber = 13;
      private bool hasWheelchairBoarding;
      private global::GTFSData.Types.Accessibility wheelchairBoarding_ = global::GTFSData.Types.Accessibility.NO_INFO;
      public bool HasWheelchairBoarding {
        get { return hasWheelchairBoarding; }
      }
      public global::GTFSData.Types.Accessibility WheelchairBoarding {
        get { return wheelchairBoarding_; }
      }
      
      public override bool IsInitialized {
        get {
          if (!hasStopId) return false;
          if (!hasStopName) return false;
          if (!hasStopLat) return false;
          if (!hasStopLon) return false;
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _stopFieldNames;
        if (hasStopId) {
          output.WriteString(1, field_names[4], StopId);
        }
        if (hasStopCode) {
          output.WriteString(2, field_names[2], StopCode);
        }
        if (hasStopName) {
          output.WriteString(3, field_names[7], StopName);
        }
        if (hasStopDesc) {
          output.WriteString(4, field_names[3], StopDesc);
        }
        if (hasStopLat) {
          output.WriteString(6, field_names[5], StopLat);
        }
        if (hasStopLon) {
          output.WriteString(7, field_names[6], StopLon);
        }
        if (hasZoneId) {
          output.WriteString(8, field_names[11], ZoneId);
        }
        if (hasStopUrl) {
          output.WriteString(9, field_names[9], StopUrl);
        }
        if (hasLocationType) {
          output.WriteEnum(10, field_names[0], (int) LocationType, LocationType);
        }
        if (hasParentStation) {
          output.WriteString(11, field_names[1], ParentStation);
        }
        if (hasStopTimezone) {
          output.WriteString(12, field_names[8], StopTimezone);
        }
        if (hasWheelchairBoarding) {
          output.WriteEnum(13, field_names[10], (int) WheelchairBoarding, WheelchairBoarding);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasStopId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, StopId);
          }
          if (hasStopCode) {
            size += pb::CodedOutputStream.ComputeStringSize(2, StopCode);
          }
          if (hasStopName) {
            size += pb::CodedOutputStream.ComputeStringSize(3, StopName);
          }
          if (hasStopDesc) {
            size += pb::CodedOutputStream.ComputeStringSize(4, StopDesc);
          }
          if (hasStopLat) {
            size += pb::CodedOutputStream.ComputeStringSize(6, StopLat);
          }
          if (hasStopLon) {
            size += pb::CodedOutputStream.ComputeStringSize(7, StopLon);
          }
          if (hasZoneId) {
            size += pb::CodedOutputStream.ComputeStringSize(8, ZoneId);
          }
          if (hasStopUrl) {
            size += pb::CodedOutputStream.ComputeStringSize(9, StopUrl);
          }
          if (hasLocationType) {
            size += pb::CodedOutputStream.ComputeEnumSize(10, (int) LocationType);
          }
          if (hasParentStation) {
            size += pb::CodedOutputStream.ComputeStringSize(11, ParentStation);
          }
          if (hasStopTimezone) {
            size += pb::CodedOutputStream.ComputeStringSize(12, StopTimezone);
          }
          if (hasWheelchairBoarding) {
            size += pb::CodedOutputStream.ComputeEnumSize(13, (int) WheelchairBoarding);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static Stop ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Stop ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Stop ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Stop ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Stop ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Stop ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static Stop ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static Stop ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static Stop ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Stop ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private Stop MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(Stop prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<Stop, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(Stop cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private Stop result;
        
        private Stop PrepareBuilder() {
          if (resultIsReadOnly) {
            Stop original = result;
            result = new Stop();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override Stop MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.Stop.Descriptor; }
        }
        
        public override Stop DefaultInstanceForType {
          get { return global::GTFSData.Types.Stop.DefaultInstance; }
        }
        
        public override Stop BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is Stop) {
            return MergeFrom((Stop) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(Stop other) {
          if (other == global::GTFSData.Types.Stop.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasStopId) {
            StopId = other.StopId;
          }
          if (other.HasStopCode) {
            StopCode = other.StopCode;
          }
          if (other.HasStopName) {
            StopName = other.StopName;
          }
          if (other.HasStopDesc) {
            StopDesc = other.StopDesc;
          }
          if (other.HasStopLat) {
            StopLat = other.StopLat;
          }
          if (other.HasStopLon) {
            StopLon = other.StopLon;
          }
          if (other.HasZoneId) {
            ZoneId = other.ZoneId;
          }
          if (other.HasStopUrl) {
            StopUrl = other.StopUrl;
          }
          if (other.HasLocationType) {
            LocationType = other.LocationType;
          }
          if (other.HasParentStation) {
            ParentStation = other.ParentStation;
          }
          if (other.HasStopTimezone) {
            StopTimezone = other.StopTimezone;
          }
          if (other.HasWheelchairBoarding) {
            WheelchairBoarding = other.WheelchairBoarding;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_stopFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _stopFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasStopId = input.ReadString(ref result.stopId_);
                break;
              }
              case 18: {
                result.hasStopCode = input.ReadString(ref result.stopCode_);
                break;
              }
              case 26: {
                result.hasStopName = input.ReadString(ref result.stopName_);
                break;
              }
              case 34: {
                result.hasStopDesc = input.ReadString(ref result.stopDesc_);
                break;
              }
              case 50: {
                result.hasStopLat = input.ReadString(ref result.stopLat_);
                break;
              }
              case 58: {
                result.hasStopLon = input.ReadString(ref result.stopLon_);
                break;
              }
              case 66: {
                result.hasZoneId = input.ReadString(ref result.zoneId_);
                break;
              }
              case 74: {
                result.hasStopUrl = input.ReadString(ref result.stopUrl_);
                break;
              }
              case 80: {
                object unknown;
                if(input.ReadEnum(ref result.locationType_, out unknown)) {
                  result.hasLocationType = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(10, (ulong)(int)unknown);
                }
                break;
              }
              case 90: {
                result.hasParentStation = input.ReadString(ref result.parentStation_);
                break;
              }
              case 98: {
                result.hasStopTimezone = input.ReadString(ref result.stopTimezone_);
                break;
              }
              case 104: {
                object unknown;
                if(input.ReadEnum(ref result.wheelchairBoarding_, out unknown)) {
                  result.hasWheelchairBoarding = true;
                } else if(unknown is int) {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  unknownFields.MergeVarintField(13, (ulong)(int)unknown);
                }
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasStopId {
          get { return result.hasStopId; }
        }
        public string StopId {
          get { return result.StopId; }
          set { SetStopId(value); }
        }
        public Builder SetStopId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopId = true;
          result.stopId_ = value;
          return this;
        }
        public Builder ClearStopId() {
          PrepareBuilder();
          result.hasStopId = false;
          result.stopId_ = "";
          return this;
        }
        
        public bool HasStopCode {
          get { return result.hasStopCode; }
        }
        public string StopCode {
          get { return result.StopCode; }
          set { SetStopCode(value); }
        }
        public Builder SetStopCode(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopCode = true;
          result.stopCode_ = value;
          return this;
        }
        public Builder ClearStopCode() {
          PrepareBuilder();
          result.hasStopCode = false;
          result.stopCode_ = "";
          return this;
        }
        
        public bool HasStopName {
          get { return result.hasStopName; }
        }
        public string StopName {
          get { return result.StopName; }
          set { SetStopName(value); }
        }
        public Builder SetStopName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopName = true;
          result.stopName_ = value;
          return this;
        }
        public Builder ClearStopName() {
          PrepareBuilder();
          result.hasStopName = false;
          result.stopName_ = "";
          return this;
        }
        
        public bool HasStopDesc {
          get { return result.hasStopDesc; }
        }
        public string StopDesc {
          get { return result.StopDesc; }
          set { SetStopDesc(value); }
        }
        public Builder SetStopDesc(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopDesc = true;
          result.stopDesc_ = value;
          return this;
        }
        public Builder ClearStopDesc() {
          PrepareBuilder();
          result.hasStopDesc = false;
          result.stopDesc_ = "";
          return this;
        }
        
        public bool HasStopLat {
          get { return result.hasStopLat; }
        }
        public string StopLat {
          get { return result.StopLat; }
          set { SetStopLat(value); }
        }
        public Builder SetStopLat(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopLat = true;
          result.stopLat_ = value;
          return this;
        }
        public Builder ClearStopLat() {
          PrepareBuilder();
          result.hasStopLat = false;
          result.stopLat_ = "";
          return this;
        }
        
        public bool HasStopLon {
          get { return result.hasStopLon; }
        }
        public string StopLon {
          get { return result.StopLon; }
          set { SetStopLon(value); }
        }
        public Builder SetStopLon(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopLon = true;
          result.stopLon_ = value;
          return this;
        }
        public Builder ClearStopLon() {
          PrepareBuilder();
          result.hasStopLon = false;
          result.stopLon_ = "";
          return this;
        }
        
        public bool HasZoneId {
          get { return result.hasZoneId; }
        }
        public string ZoneId {
          get { return result.ZoneId; }
          set { SetZoneId(value); }
        }
        public Builder SetZoneId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasZoneId = true;
          result.zoneId_ = value;
          return this;
        }
        public Builder ClearZoneId() {
          PrepareBuilder();
          result.hasZoneId = false;
          result.zoneId_ = "";
          return this;
        }
        
        public bool HasStopUrl {
          get { return result.hasStopUrl; }
        }
        public string StopUrl {
          get { return result.StopUrl; }
          set { SetStopUrl(value); }
        }
        public Builder SetStopUrl(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopUrl = true;
          result.stopUrl_ = value;
          return this;
        }
        public Builder ClearStopUrl() {
          PrepareBuilder();
          result.hasStopUrl = false;
          result.stopUrl_ = "";
          return this;
        }
        
        public bool HasLocationType {
         get { return result.hasLocationType; }
        }
        public global::GTFSData.Types.Stop.Types.LocationType LocationType {
          get { return result.LocationType; }
          set { SetLocationType(value); }
        }
        public Builder SetLocationType(global::GTFSData.Types.Stop.Types.LocationType value) {
          PrepareBuilder();
          result.hasLocationType = true;
          result.locationType_ = value;
          return this;
        }
        public Builder ClearLocationType() {
          PrepareBuilder();
          result.hasLocationType = false;
          result.locationType_ = global::GTFSData.Types.Stop.Types.LocationType.STOP;
          return this;
        }
        
        public bool HasParentStation {
          get { return result.hasParentStation; }
        }
        public string ParentStation {
          get { return result.ParentStation; }
          set { SetParentStation(value); }
        }
        public Builder SetParentStation(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasParentStation = true;
          result.parentStation_ = value;
          return this;
        }
        public Builder ClearParentStation() {
          PrepareBuilder();
          result.hasParentStation = false;
          result.parentStation_ = "";
          return this;
        }
        
        public bool HasStopTimezone {
          get { return result.hasStopTimezone; }
        }
        public string StopTimezone {
          get { return result.StopTimezone; }
          set { SetStopTimezone(value); }
        }
        public Builder SetStopTimezone(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasStopTimezone = true;
          result.stopTimezone_ = value;
          return this;
        }
        public Builder ClearStopTimezone() {
          PrepareBuilder();
          result.hasStopTimezone = false;
          result.stopTimezone_ = "";
          return this;
        }
        
        public bool HasWheelchairBoarding {
         get { return result.hasWheelchairBoarding; }
        }
        public global::GTFSData.Types.Accessibility WheelchairBoarding {
          get { return result.WheelchairBoarding; }
          set { SetWheelchairBoarding(value); }
        }
        public Builder SetWheelchairBoarding(global::GTFSData.Types.Accessibility value) {
          PrepareBuilder();
          result.hasWheelchairBoarding = true;
          result.wheelchairBoarding_ = value;
          return this;
        }
        public Builder ClearWheelchairBoarding() {
          PrepareBuilder();
          result.hasWheelchairBoarding = false;
          result.wheelchairBoarding_ = global::GTFSData.Types.Accessibility.NO_INFO;
          return this;
        }
      }
      static Stop() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class ShapeSegment : pb::GeneratedMessage<ShapeSegment, ShapeSegment.Builder> {
      private ShapeSegment() { }
      private static readonly ShapeSegment defaultInstance = new ShapeSegment().MakeReadOnly();
      private static readonly string[] _shapeSegmentFieldNames = new string[] { "shape_dist_traveled", "shape_pt_lat", "shape_pt_lon" };
      private static readonly uint[] _shapeSegmentFieldTags = new uint[] { 26, 10, 18 };
      public static ShapeSegment DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override ShapeSegment DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override ShapeSegment ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_ShapeSegment__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<ShapeSegment, ShapeSegment.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_ShapeSegment__FieldAccessorTable; }
      }
      
      public const int ShapePtLatFieldNumber = 1;
      private bool hasShapePtLat;
      private string shapePtLat_ = "";
      public bool HasShapePtLat {
        get { return hasShapePtLat; }
      }
      public string ShapePtLat {
        get { return shapePtLat_; }
      }
      
      public const int ShapePtLonFieldNumber = 2;
      private bool hasShapePtLon;
      private string shapePtLon_ = "";
      public bool HasShapePtLon {
        get { return hasShapePtLon; }
      }
      public string ShapePtLon {
        get { return shapePtLon_; }
      }
      
      public const int ShapeDistTraveledFieldNumber = 3;
      private bool hasShapeDistTraveled;
      private string shapeDistTraveled_ = "";
      public bool HasShapeDistTraveled {
        get { return hasShapeDistTraveled; }
      }
      public string ShapeDistTraveled {
        get { return shapeDistTraveled_; }
      }
      
      public override bool IsInitialized {
        get {
          if (!hasShapePtLat) return false;
          if (!hasShapePtLon) return false;
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _shapeSegmentFieldNames;
        if (hasShapePtLat) {
          output.WriteString(1, field_names[1], ShapePtLat);
        }
        if (hasShapePtLon) {
          output.WriteString(2, field_names[2], ShapePtLon);
        }
        if (hasShapeDistTraveled) {
          output.WriteString(3, field_names[0], ShapeDistTraveled);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasShapePtLat) {
            size += pb::CodedOutputStream.ComputeStringSize(1, ShapePtLat);
          }
          if (hasShapePtLon) {
            size += pb::CodedOutputStream.ComputeStringSize(2, ShapePtLon);
          }
          if (hasShapeDistTraveled) {
            size += pb::CodedOutputStream.ComputeStringSize(3, ShapeDistTraveled);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static ShapeSegment ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static ShapeSegment ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static ShapeSegment ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static ShapeSegment ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static ShapeSegment ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private ShapeSegment MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(ShapeSegment prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<ShapeSegment, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(ShapeSegment cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private ShapeSegment result;
        
        private ShapeSegment PrepareBuilder() {
          if (resultIsReadOnly) {
            ShapeSegment original = result;
            result = new ShapeSegment();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override ShapeSegment MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.ShapeSegment.Descriptor; }
        }
        
        public override ShapeSegment DefaultInstanceForType {
          get { return global::GTFSData.Types.ShapeSegment.DefaultInstance; }
        }
        
        public override ShapeSegment BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is ShapeSegment) {
            return MergeFrom((ShapeSegment) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(ShapeSegment other) {
          if (other == global::GTFSData.Types.ShapeSegment.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasShapePtLat) {
            ShapePtLat = other.ShapePtLat;
          }
          if (other.HasShapePtLon) {
            ShapePtLon = other.ShapePtLon;
          }
          if (other.HasShapeDistTraveled) {
            ShapeDistTraveled = other.ShapeDistTraveled;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_shapeSegmentFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _shapeSegmentFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasShapePtLat = input.ReadString(ref result.shapePtLat_);
                break;
              }
              case 18: {
                result.hasShapePtLon = input.ReadString(ref result.shapePtLon_);
                break;
              }
              case 26: {
                result.hasShapeDistTraveled = input.ReadString(ref result.shapeDistTraveled_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasShapePtLat {
          get { return result.hasShapePtLat; }
        }
        public string ShapePtLat {
          get { return result.ShapePtLat; }
          set { SetShapePtLat(value); }
        }
        public Builder SetShapePtLat(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasShapePtLat = true;
          result.shapePtLat_ = value;
          return this;
        }
        public Builder ClearShapePtLat() {
          PrepareBuilder();
          result.hasShapePtLat = false;
          result.shapePtLat_ = "";
          return this;
        }
        
        public bool HasShapePtLon {
          get { return result.hasShapePtLon; }
        }
        public string ShapePtLon {
          get { return result.ShapePtLon; }
          set { SetShapePtLon(value); }
        }
        public Builder SetShapePtLon(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasShapePtLon = true;
          result.shapePtLon_ = value;
          return this;
        }
        public Builder ClearShapePtLon() {
          PrepareBuilder();
          result.hasShapePtLon = false;
          result.shapePtLon_ = "";
          return this;
        }
        
        public bool HasShapeDistTraveled {
          get { return result.hasShapeDistTraveled; }
        }
        public string ShapeDistTraveled {
          get { return result.ShapeDistTraveled; }
          set { SetShapeDistTraveled(value); }
        }
        public Builder SetShapeDistTraveled(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasShapeDistTraveled = true;
          result.shapeDistTraveled_ = value;
          return this;
        }
        public Builder ClearShapeDistTraveled() {
          PrepareBuilder();
          result.hasShapeDistTraveled = false;
          result.shapeDistTraveled_ = "";
          return this;
        }
      }
      static ShapeSegment() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Shape : pb::GeneratedMessage<Shape, Shape.Builder> {
      private Shape() { }
      private static readonly Shape defaultInstance = new Shape().MakeReadOnly();
      private static readonly string[] _shapeFieldNames = new string[] { "shape_id", "shapes" };
      private static readonly uint[] _shapeFieldTags = new uint[] { 10, 18 };
      public static Shape DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override Shape DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override Shape ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Gtfsdata.internal__static_GTFSData_Shape__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<Shape, Shape.Builder> InternalFieldAccessors {
        get { return global::Gtfsdata.internal__static_GTFSData_Shape__FieldAccessorTable; }
      }
      
      public const int ShapeIdFieldNumber = 1;
      private bool hasShapeId;
      private string shapeId_ = "";
      public bool HasShapeId {
        get { return hasShapeId; }
      }
      public string ShapeId {
        get { return shapeId_; }
      }
      
      public const int ShapesFieldNumber = 2;
      private pbc::PopsicleList<global::GTFSData.Types.ShapeSegment> shapes_ = new pbc::PopsicleList<global::GTFSData.Types.ShapeSegment>();
      public scg::IList<global::GTFSData.Types.ShapeSegment> ShapesList {
        get { return shapes_; }
      }
      public int ShapesCount {
        get { return shapes_.Count; }
      }
      public global::GTFSData.Types.ShapeSegment GetShapes(int index) {
        return shapes_[index];
      }
      
      public override bool IsInitialized {
        get {
          if (!hasShapeId) return false;
          foreach (global::GTFSData.Types.ShapeSegment element in ShapesList) {
            if (!element.IsInitialized) return false;
          }
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _shapeFieldNames;
        if (hasShapeId) {
          output.WriteString(1, field_names[0], ShapeId);
        }
        if (shapes_.Count > 0) {
          output.WriteMessageArray(2, field_names[1], shapes_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasShapeId) {
            size += pb::CodedOutputStream.ComputeStringSize(1, ShapeId);
          }
          foreach (global::GTFSData.Types.ShapeSegment element in ShapesList) {
            size += pb::CodedOutputStream.ComputeMessageSize(2, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static Shape ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Shape ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Shape ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static Shape ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static Shape ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Shape ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static Shape ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static Shape ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static Shape ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static Shape ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private Shape MakeReadOnly() {
        shapes_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(Shape prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<Shape, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(Shape cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private Shape result;
        
        private Shape PrepareBuilder() {
          if (resultIsReadOnly) {
            Shape original = result;
            result = new Shape();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override Shape MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::GTFSData.Types.Shape.Descriptor; }
        }
        
        public override Shape DefaultInstanceForType {
          get { return global::GTFSData.Types.Shape.DefaultInstance; }
        }
        
        public override Shape BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is Shape) {
            return MergeFrom((Shape) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(Shape other) {
          if (other == global::GTFSData.Types.Shape.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasShapeId) {
            ShapeId = other.ShapeId;
          }
          if (other.shapes_.Count != 0) {
            result.shapes_.Add(other.shapes_);
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_shapeFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _shapeFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasShapeId = input.ReadString(ref result.shapeId_);
                break;
              }
              case 18: {
                input.ReadMessageArray(tag, field_name, result.shapes_, global::GTFSData.Types.ShapeSegment.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasShapeId {
          get { return result.hasShapeId; }
        }
        public string ShapeId {
          get { return result.ShapeId; }
          set { SetShapeId(value); }
        }
        public Builder SetShapeId(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasShapeId = true;
          result.shapeId_ = value;
          return this;
        }
        public Builder ClearShapeId() {
          PrepareBuilder();
          result.hasShapeId = false;
          result.shapeId_ = "";
          return this;
        }
        
        public pbc::IPopsicleList<global::GTFSData.Types.ShapeSegment> ShapesList {
          get { return PrepareBuilder().shapes_; }
        }
        public int ShapesCount {
          get { return result.ShapesCount; }
        }
        public global::GTFSData.Types.ShapeSegment GetShapes(int index) {
          return result.GetShapes(index);
        }
        public Builder SetShapes(int index, global::GTFSData.Types.ShapeSegment value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.shapes_[index] = value;
          return this;
        }
        public Builder SetShapes(int index, global::GTFSData.Types.ShapeSegment.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.shapes_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddShapes(global::GTFSData.Types.ShapeSegment value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.shapes_.Add(value);
          return this;
        }
        public Builder AddShapes(global::GTFSData.Types.ShapeSegment.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.shapes_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeShapes(scg::IEnumerable<global::GTFSData.Types.ShapeSegment> values) {
          PrepareBuilder();
          result.shapes_.Add(values);
          return this;
        }
        public Builder ClearShapes() {
          PrepareBuilder();
          result.shapes_.Clear();
          return this;
        }
      }
      static Shape() {
        object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _gTFSDataFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static GTFSData ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static GTFSData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static GTFSData ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static GTFSData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static GTFSData ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static GTFSData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static GTFSData ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static GTFSData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static GTFSData ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static GTFSData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private GTFSData MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(GTFSData prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<GTFSData, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(GTFSData cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private GTFSData result;
    
    private GTFSData PrepareBuilder() {
      if (resultIsReadOnly) {
        GTFSData original = result;
        result = new GTFSData();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override GTFSData MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::GTFSData.Descriptor; }
    }
    
    public override GTFSData DefaultInstanceForType {
      get { return global::GTFSData.DefaultInstance; }
    }
    
    public override GTFSData BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is GTFSData) {
        return MergeFrom((GTFSData) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(GTFSData other) {
      if (other == global::GTFSData.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_gTFSDataFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _gTFSDataFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static GTFSData() {
    object.ReferenceEquals(global::Gtfsdata.Descriptor, null);
  }
}

#endregion


#endregion Designer generated code
