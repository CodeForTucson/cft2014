#
# reads a sqlite file generated by parse_gtfs_data.py
# and outputs X amount of routes , and only outputting the data associated with those routes
# back into a zip file full of csv files.
#
#
# Mark Grandi - Aug 20, 2014
#


import argparse, sys, sqlite3, os.path, logging, collections, io, csv, zipfile, pathlib

SqliteResult = collections.namedtuple("SqliteResult", ["filepath", "conn"])
TripsResult = collections.namedtuple("TripsResult", ["listOfTrips", "listOfShapes"])

def sqliteToCsvZip(args):
    '''takes a sqlite file from parse_gtfs_data.py and only outputs X amount of routes to the GTFS zip format
    @param args - the namespace object we get from argparse.parse_args()
    '''

    lg = logging.getLogger("main")

    if args.verbose:
        lg.setLevel("DEBUG")

    lg.debug("Using sqlite database at: {}".format(args.sqliteInput.filepath))

    db = args.sqliteInput.conn

    # files we will be writing to
    routesTxtOutput = io.StringIO(newline='')
    stopsTxtOutput = io.StringIO(newline='')
    tripsTxtOutput = io.StringIO(newline='')
    stopTimesTxtOutput = io.StringIO(newline='')
    shapesTxtOutput = io.StringIO(newline='')



    listOfRoutes = handleRoutesTxt(routesTxtOutput, args.routeLimit, db, lg)


    # now that we have the list of what routes we are considering, we go through the rest of the data and only output
    # the data that links to these routes
    tripResult = handleTripsTxt(tripsTxtOutput, listOfRoutes, db, lg)

    # then do stop_times , which correspond to the trip_ids that we have
    stopIdList = handleStopTimesTxt(stopTimesTxtOutput, tripResult.listOfTrips, db, lg)

    # then do stops, which correspond to the stop_ids that we have 
    handleStopsTxt(stopsTxtOutput, stopIdList, db, lg)

    # then do shapes
    handleShapesTxt(shapesTxtOutput, tripResult.listOfShapes, db, lg)


    lg.info("Creating zip file, saving it to {}".format(pathlib.Path(args.gtfsZipOutput.name).resolve()))
    # now create the zipfile
    with zipfile.ZipFile(args.gtfsZipOutput, "w") as theZipFile:

        theZipFile.writestr("routes.txt", routesTxtOutput.getvalue().encode("utf-8"))
        theZipFile.writestr("shapes.txt", shapesTxtOutput.getvalue().encode("utf-8"))
        theZipFile.writestr("stops.txt", stopsTxtOutput.getvalue().encode("utf-8"))
        theZipFile.writestr("stop_times.txt", stopTimesTxtOutput.getvalue().encode("utf-8"))
        theZipFile.writestr("trips.txt", tripsTxtOutput.getvalue().encode("utf-8"))

    lg.info("done")



def handleRoutesTxt(routesTxtOutput, routeLimit, dbCon, logger):
    ''' handles writing @routeLimit number of entries to the routes.txt csv output 
    and then returning a list of the route_ids we wrote'''

    resultList = list()

    log = logger.getChild("routes")

    log.debug("Starting handleRoutesTxt()")

    # select @limit number of routes from the database
    fldNames = ["route_id","agency_id","route_short_name","route_long_name","route_desc",
        "route_type","route_url","route_color","route_text_color"]
    csvWriter = csv.DictWriter(routesTxtOutput, fldNames)
    try:
        cur = dbCon.cursor()
        cur.execute("SELECT * FROM routes LIMIT {}".format(routeLimit))

        # add the route_id to the list we are returning
        for iterRow in cur.fetchall():
            resultList.append(iterRow["route_id"])

            # write it to the csv
            csvWriter.writerow(dict(iterRow))

    except Exception as e:
        log.exception("Something wrong happened in handleRoutesTxt()...")
        raise e

    log.debug("\twrote {} routes".format(routeLimit))

    return resultList


def handleTripsTxt(tripsTxtOutput, routeList, dbCon, logger):
    ''' handles writing entries to the tripsTxtOutput csvfile from the 'trips' table in the database,
    but only ones that have 'route_id = <entry in routeList>'

    returns a TripResult that has a list of trip ids and a list of shape ids that we outputted '''

    resultListTrip = list()
    resultSetShape = set()

    log = logger.getChild("trips")
    log.debug("Starting handleTripsTxt()")

    fldNames = ["route_id","service_id","trip_id","trip_headsign","trip_short_name","direction_id",
        "block_id","shape_id"]
    csvWriter = csv.DictWriter(tripsTxtOutput, fldNames)

    routeCounter = 0
    tripCounter = 0
    try:
        cursor = dbCon.cursor()

        for iterRouteId in routeList:
            #log.debug("\ton route {}".format(iterRouteId))
            cursor.execute("SELECT * FROM trips WHERE route_id = ?", (iterRouteId,))
            for iterRow in cursor.fetchall():
                resultListTrip.append(iterRow["trip_id"])
                resultSetShape.add(iterRow["shape_id"])

                csvWriter.writerow(dict(iterRow))

                tripCounter += 1
            routeCounter += 1


    except Exception as e:
        log.exception("Something wrong happened in handleTripsTxt()...")
        raise e

    log.debug("\twrote {} trip rows for {} routes".format(tripCounter, routeCounter))

    return TripsResult(resultListTrip, list(resultSetShape))


def handleStopTimesTxt(stopTimesTxtOutput, tripIdList, dbCon, logger):
    ''' handles writing  entries to the stop_times.txt csv output based on the list of trip_ids we get passed in
    and then returning a list of the stop_ids we wrote'''

    resultSet = set()

    log = logger.getChild("stop_times")

    log.debug("Starting handleStopTimesTxt()")

    # select @limit number of routes from the database
    fldNames = ["trip_id","arrival_time","departure_time","stop_id","stop_sequence","stop_headsign",
        "pickup_type","drop_off_type","shape_dist_traveled"]
    csvWriter = csv.DictWriter(stopTimesTxtOutput, fldNames)
    try:
        cur = dbCon.cursor()
        
        tripCounter = 0
        stopTimeCounter = 0
        for iterTripId in tripIdList:
            #log.debug("\ton trip_id {}".format(iterTripId))

            tripCounter += 1
            cur.execute("SELECT * FROM stop_times WHERE trip_id = ?", (iterTripId,))

            # add the route_id to the list we are returning
            for iterRow in cur.fetchall():
                stopTimeCounter += 1
                resultSet.add(iterRow["stop_id"])

                # write it to the csv
                csvWriter.writerow(dict(iterRow))

    except Exception as e:
        log.exception("Something wrong happened in handleStopTimesTxt()...")
        raise e

    log.debug("\twrote {} stop times in {} trips".format(stopTimeCounter, tripCounter))

    return list(resultSet)


def handleStopsTxt(stopsTxtOutput, listOfStopIds, dbCon, logger):
    ''' write to the stops.txt csv fileobj all of the stops that correspond to an entry in listOfStopIds'''


    listOfStopIds = sorted(listOfStopIds)

    log = logger.getChild("stops")

    log.debug("Starting handleStopsTxt()")

    # select @limit number of routes from the database
    fldNames = ["stop_id","stop_code","stop_name","stop_desc","stop_lat","stop_lon",
        "zone_id","stop_url","location_type","parent_station","wheelchair_boarding"]
    csvWriter = csv.DictWriter(stopsTxtOutput, fldNames)
    try:
        cur = dbCon.cursor()
        
        for iterStopId in listOfStopIds:
            #log.debug("\ton stop_id {}".format(iterStopId))

            cur.execute("SELECT * FROM stops WHERE stop_id = ?", (iterStopId,))

            # add the route_id to the list we are returning
            for iterRow in cur.fetchall():
                # write it to the csv
                csvWriter.writerow(dict(iterRow))

    except Exception as e:
        log.exception("Something wrong happened in handleStopsTxt()...")
        raise e

    log.debug("\twrote {} stops".format(len(listOfStopIds)))


def handleShapesTxt(shapesTxtOutput, listOfShapeIds, dbCon, logger):
    ''' write to the shapes.txt csv fileobj all of the shapes that correspond to trip entries'''


    log = logger.getChild("shapes")

    log.debug("Starting handleShapesTxt()")

    # select @limit number of routes from the database
    fldNames = ["shape_id","shape_pt_lat","shape_pt_lon","shape_pt_sequence","shape_dist_traveled"]
    csvWriter = csv.DictWriter(shapesTxtOutput, fldNames)
    try:
        cur = dbCon.cursor()
        
        shapeCounter = 0
        for iterShapeId in listOfShapeIds:
            #log.debug("\ton stop_id {}".format(iterStopId))

            cur.execute("SELECT * FROM shapes WHERE shape_id = ?", (iterShapeId,))

            # add the route_id to the list we are returning
            for iterRow in cur.fetchall():
                shapeCounter += 1
                # write it to the csv
                csvWriter.writerow(dict(iterRow))

    except Exception as e:
        log.exception("Something wrong happened in handleShapesTxt()...")
        raise e

    log.debug("\twrote {} shapes".format(shapeCounter))

def isSqliteType(dbLocationArg):
        ''' see if the file we wanted to connect to actually is a database,
        raises an ArgumentTypeError if its not a sqlite3 database
        @param dbLocationArg - the location of the database from parser.parse_args()
        @return the sqlite3 db connection, else we raise an exception
        '''

        dbLocation = os.path.realpath(dbLocationArg)

        # make sure this is a file
        if not os.path.isfile(dbLocation):
            raise argparse.ArgumentTypeError("{} is not a file!".format(dbLocation))

        # make the connection
        tmpConnection = sqlite3.connect(dbLocation)
        tmpConnection.row_factory = sqlite3.Row
        tmpCursor = tmpConnection.cursor()
            
        try:
            # try getting something from the master table
            tmpCursor.execute('''select * from sqlite_master limit 1''')
        except sqlite3.DatabaseError as e:
            tmpCursor.close()
            tmpConnection.close()
            raise argparse.ArgumentTypeError("the file at {} is not a sqlite3 database! error: {}".format(dbLocation, e))

        except Exception as e1:
            tmpCursor.close()
            tmpConnection.close()
            raise argparse.ArgumentTypeError("Something else went wrong with the sqlite db at {}, error: {}".format(dbLocation, e))
        

        # table is an actual sqlite3 table
        return SqliteResult(dbLocation, tmpConnection)

if __name__ == "__main__":
    # if we are being run as a real program

    parser = argparse.ArgumentParser(description="takes a sqlite file from parse_gtfs_data.py and only outputs X amount of routes to the GTFS zip format", 
    epilog="Copyright Aug 20, 2014 Mark Grandi")

    # optional arguments, if specified these are the input and output files, if not specified, it uses stdin and stdout
    parser.add_argument('sqliteInput', type=isSqliteType, help="the sqlite file generated from parse_gtfs_data.py")
    parser.add_argument('gtfsZipOutput', type=argparse.FileType("wb"), help="where to write the GTFS zip when we are done")
    parser.add_argument("routeLimit", type=int, default=1, help="the amount of routes (and all other data associated) to output")
    parser.add_argument('--verbose', '-v', action="store_true", help="increase verbosity")

    logging.basicConfig(level="INFO", format='%(asctime)s %(name)-12s %(levelname)-8s: %(message)s')

    try:
        sqliteToCsvZip(parser.parse_args())
    except Exception as e:
        logging.exception("An error occured")
